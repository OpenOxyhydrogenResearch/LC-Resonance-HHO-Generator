// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

// Begin prologue.
//
//
// End prologue.

#include "uix_config-pskel.hxx"

// UIXConfig_pskel
//

void UIXConfig_pskel::
locale_parser (::xml_schema::string_pskel& p)
{
  this->locale_parser_ = &p;
}

void UIXConfig_pskel::
ApplicationStates_parser (::ApplicationStates_pskel& p)
{
  this->ApplicationStates_parser_ = &p;
}

void UIXConfig_pskel::
parsers (::xml_schema::string_pskel& locale,
         ::ApplicationStates_pskel& ApplicationStates)
{
  this->locale_parser_ = &locale;
  this->ApplicationStates_parser_ = &ApplicationStates;
}

UIXConfig_pskel::
UIXConfig_pskel ()
: UIXConfig_impl_ (0),
  locale_parser_ (0),
  ApplicationStates_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

UIXConfig_pskel::
UIXConfig_pskel (UIXConfig_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  UIXConfig_impl_ (impl),
  locale_parser_ (0),
  ApplicationStates_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ApplicationStates_pskel
//

void ApplicationStates_pskel::
AppState_parser (::AppState_pskel& p)
{
  this->AppState_parser_ = &p;
}

void ApplicationStates_pskel::
parsers (::AppState_pskel& AppState)
{
  this->AppState_parser_ = &AppState;
}

ApplicationStates_pskel::
ApplicationStates_pskel ()
: ApplicationStates_impl_ (0),
  AppState_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

ApplicationStates_pskel::
ApplicationStates_pskel (ApplicationStates_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  ApplicationStates_impl_ (impl),
  AppState_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// AppState_pskel
//

void AppState_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void AppState_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void AppState_pskel::
desc_parser (::xml_schema::string_pskel& p)
{
  this->desc_parser_ = &p;
}

void AppState_pskel::
AppModes_parser (::AppModes_pskel& p)
{
  this->AppModes_parser_ = &p;
}

void AppState_pskel::
ScreenObjects_parser (::ScreenObjects_pskel& p)
{
  this->ScreenObjects_parser_ = &p;
}

void AppState_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::xml_schema::string_pskel& name,
         ::xml_schema::string_pskel& desc,
         ::AppModes_pskel& AppModes,
         ::ScreenObjects_pskel& ScreenObjects)
{
  this->id_parser_ = &id;
  this->name_parser_ = &name;
  this->desc_parser_ = &desc;
  this->AppModes_parser_ = &AppModes;
  this->ScreenObjects_parser_ = &ScreenObjects;
}

AppState_pskel::
AppState_pskel ()
: AppState_impl_ (0),
  id_parser_ (0),
  name_parser_ (0),
  desc_parser_ (0),
  AppModes_parser_ (0),
  ScreenObjects_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

AppState_pskel::
AppState_pskel (AppState_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  AppState_impl_ (impl),
  id_parser_ (0),
  name_parser_ (0),
  desc_parser_ (0),
  AppModes_parser_ (0),
  ScreenObjects_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// mode_pskel
//

void mode_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void mode_pskel::
desc_parser (::xml_schema::string_pskel& p)
{
  this->desc_parser_ = &p;
}

void mode_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::xml_schema::string_pskel& desc)
{
  this->id_parser_ = &id;
  this->desc_parser_ = &desc;
}

mode_pskel::
mode_pskel (::xml_schema::byte_pskel* tiein)
: ::xml_schema::byte_pskel (tiein, 0),
  mode_impl_ (0),
  id_parser_ (0),
  desc_parser_ (0)
{
}

mode_pskel::
mode_pskel (mode_pskel* impl, void*)
: ::xml_schema::byte_pskel (impl, 0),
  mode_impl_ (impl),
  id_parser_ (0),
  desc_parser_ (0)
{
}

// AppModes_pskel
//

void AppModes_pskel::
mode_parser (::mode_pskel& p)
{
  this->mode_parser_ = &p;
}

void AppModes_pskel::
parsers (::mode_pskel& mode)
{
  this->mode_parser_ = &mode;
}

AppModes_pskel::
AppModes_pskel ()
: AppModes_impl_ (0),
  mode_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

AppModes_pskel::
AppModes_pskel (AppModes_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  AppModes_impl_ (impl),
  mode_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ScreenObjects_pskel
//

void ScreenObjects_pskel::
LCDCharacterLine_parser (::LCDCharacterLine_pskel& p)
{
  this->LCDCharacterLine_parser_ = &p;
}

void ScreenObjects_pskel::
parsers (::LCDCharacterLine_pskel& LCDCharacterLine)
{
  this->LCDCharacterLine_parser_ = &LCDCharacterLine;
}

ScreenObjects_pskel::
ScreenObjects_pskel ()
: ScreenObjects_impl_ (0),
  LCDCharacterLine_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

ScreenObjects_pskel::
ScreenObjects_pskel (ScreenObjects_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  ScreenObjects_impl_ (impl),
  LCDCharacterLine_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// textObj_pskel
//

void textObj_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void textObj_pskel::
desc_parser (::xml_schema::string_pskel& p)
{
  this->desc_parser_ = &p;
}

void textObj_pskel::
xpos_min_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_min_parser_ = &p;
}

void textObj_pskel::
xpos_max_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_max_parser_ = &p;
}

void textObj_pskel::
xcount_parser (::xml_schema::byte_pskel& p)
{
  this->xcount_parser_ = &p;
}

void textObj_pskel::
align_parser (::xml_schema::string_pskel& p)
{
  this->align_parser_ = &p;
}

void textObj_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::xml_schema::string_pskel& desc,
         ::xml_schema::byte_pskel& xpos_min,
         ::xml_schema::byte_pskel& xpos_max,
         ::xml_schema::byte_pskel& xcount,
         ::xml_schema::string_pskel& align)
{
  this->id_parser_ = &id;
  this->desc_parser_ = &desc;
  this->xpos_min_parser_ = &xpos_min;
  this->xpos_max_parser_ = &xpos_max;
  this->xcount_parser_ = &xcount;
  this->align_parser_ = &align;
}

textObj_pskel::
textObj_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  textObj_impl_ (0),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0),
  align_parser_ (0)
{
}

textObj_pskel::
textObj_pskel (textObj_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  textObj_impl_ (impl),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0),
  align_parser_ (0)
{
}

// durationValue_pskel
//

void durationValue_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void durationValue_pskel::
desc_parser (::xml_schema::string_pskel& p)
{
  this->desc_parser_ = &p;
}

void durationValue_pskel::
xpos_min_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_min_parser_ = &p;
}

void durationValue_pskel::
xpos_max_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_max_parser_ = &p;
}

void durationValue_pskel::
xcount_parser (::xml_schema::byte_pskel& p)
{
  this->xcount_parser_ = &p;
}

void durationValue_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::xml_schema::string_pskel& desc,
         ::xml_schema::byte_pskel& xpos_min,
         ::xml_schema::byte_pskel& xpos_max,
         ::xml_schema::byte_pskel& xcount)
{
  this->id_parser_ = &id;
  this->desc_parser_ = &desc;
  this->xpos_min_parser_ = &xpos_min;
  this->xpos_max_parser_ = &xpos_max;
  this->xcount_parser_ = &xcount;
}

durationValue_pskel::
durationValue_pskel (::xml_schema::byte_pskel* tiein)
: ::xml_schema::byte_pskel (tiein, 0),
  durationValue_impl_ (0),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0)
{
}

durationValue_pskel::
durationValue_pskel (durationValue_pskel* impl, void*)
: ::xml_schema::byte_pskel (impl, 0),
  durationValue_impl_ (impl),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0)
{
}

// dispUnit1_pskel
//

void dispUnit1_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void dispUnit1_pskel::
desc_parser (::xml_schema::string_pskel& p)
{
  this->desc_parser_ = &p;
}

void dispUnit1_pskel::
xpos_min_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_min_parser_ = &p;
}

void dispUnit1_pskel::
xpos_max_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_max_parser_ = &p;
}

void dispUnit1_pskel::
xcount_parser (::xml_schema::byte_pskel& p)
{
  this->xcount_parser_ = &p;
}

void dispUnit1_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::xml_schema::string_pskel& desc,
         ::xml_schema::byte_pskel& xpos_min,
         ::xml_schema::byte_pskel& xpos_max,
         ::xml_schema::byte_pskel& xcount)
{
  this->id_parser_ = &id;
  this->desc_parser_ = &desc;
  this->xpos_min_parser_ = &xpos_min;
  this->xpos_max_parser_ = &xpos_max;
  this->xcount_parser_ = &xcount;
}

dispUnit1_pskel::
dispUnit1_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  dispUnit1_impl_ (0),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0)
{
}

dispUnit1_pskel::
dispUnit1_pskel (dispUnit1_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  dispUnit1_impl_ (impl),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0)
{
}

// DispDuration_pskel
//

void DispDuration_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void DispDuration_pskel::
durationValue_parser (::durationValue_pskel& p)
{
  this->durationValue_parser_ = &p;
}

void DispDuration_pskel::
dispUnit_parser (::dispUnit1_pskel& p)
{
  this->dispUnit_parser_ = &p;
}

void DispDuration_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::durationValue_pskel& durationValue,
         ::dispUnit1_pskel& dispUnit)
{
  this->id_parser_ = &id;
  this->durationValue_parser_ = &durationValue;
  this->dispUnit_parser_ = &dispUnit;
}

DispDuration_pskel::
DispDuration_pskel ()
: DispDuration_impl_ (0),
  id_parser_ (0),
  durationValue_parser_ (0),
  dispUnit_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

DispDuration_pskel::
DispDuration_pskel (DispDuration_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  DispDuration_impl_ (impl),
  id_parser_ (0),
  durationValue_parser_ (0),
  dispUnit_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// DispIdentifier_pskel
//

void DispIdentifier_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void DispIdentifier_pskel::
desc_parser (::xml_schema::string_pskel& p)
{
  this->desc_parser_ = &p;
}

void DispIdentifier_pskel::
xpos_min_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_min_parser_ = &p;
}

void DispIdentifier_pskel::
xpos_max_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_max_parser_ = &p;
}

void DispIdentifier_pskel::
xcount_parser (::xml_schema::byte_pskel& p)
{
  this->xcount_parser_ = &p;
}

void DispIdentifier_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::xml_schema::string_pskel& desc,
         ::xml_schema::byte_pskel& xpos_min,
         ::xml_schema::byte_pskel& xpos_max,
         ::xml_schema::byte_pskel& xcount)
{
  this->id_parser_ = &id;
  this->desc_parser_ = &desc;
  this->xpos_min_parser_ = &xpos_min;
  this->xpos_max_parser_ = &xpos_max;
  this->xcount_parser_ = &xcount;
}

DispIdentifier_pskel::
DispIdentifier_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  DispIdentifier_impl_ (0),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0)
{
}

DispIdentifier_pskel::
DispIdentifier_pskel (DispIdentifier_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  DispIdentifier_impl_ (impl),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0)
{
}

// dispUnit2_pskel
//

void dispUnit2_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void dispUnit2_pskel::
desc_parser (::xml_schema::string_pskel& p)
{
  this->desc_parser_ = &p;
}

void dispUnit2_pskel::
xpos_min_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_min_parser_ = &p;
}

void dispUnit2_pskel::
xpos_max_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_max_parser_ = &p;
}

void dispUnit2_pskel::
xcount_parser (::xml_schema::byte_pskel& p)
{
  this->xcount_parser_ = &p;
}

void dispUnit2_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::xml_schema::string_pskel& desc,
         ::xml_schema::byte_pskel& xpos_min,
         ::xml_schema::byte_pskel& xpos_max,
         ::xml_schema::byte_pskel& xcount)
{
  this->id_parser_ = &id;
  this->desc_parser_ = &desc;
  this->xpos_min_parser_ = &xpos_min;
  this->xpos_max_parser_ = &xpos_max;
  this->xcount_parser_ = &xcount;
}

dispUnit2_pskel::
dispUnit2_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  dispUnit2_impl_ (0),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0)
{
}

dispUnit2_pskel::
dispUnit2_pskel (dispUnit2_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  dispUnit2_impl_ (impl),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0)
{
}

// dutyCycle_pskel
//

void dutyCycle_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void dutyCycle_pskel::
desc_parser (::xml_schema::string_pskel& p)
{
  this->desc_parser_ = &p;
}

void dutyCycle_pskel::
xpos_min_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_min_parser_ = &p;
}

void dutyCycle_pskel::
xpos_max_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_max_parser_ = &p;
}

void dutyCycle_pskel::
xcount_parser (::xml_schema::byte_pskel& p)
{
  this->xcount_parser_ = &p;
}

void dutyCycle_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::xml_schema::string_pskel& desc,
         ::xml_schema::byte_pskel& xpos_min,
         ::xml_schema::byte_pskel& xpos_max,
         ::xml_schema::byte_pskel& xcount)
{
  this->id_parser_ = &id;
  this->desc_parser_ = &desc;
  this->xpos_min_parser_ = &xpos_min;
  this->xpos_max_parser_ = &xpos_max;
  this->xcount_parser_ = &xcount;
}

dutyCycle_pskel::
dutyCycle_pskel (::xml_schema::float_pskel* tiein)
: ::xml_schema::float_pskel (tiein, 0),
  dutyCycle_impl_ (0),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0)
{
}

dutyCycle_pskel::
dutyCycle_pskel (dutyCycle_pskel* impl, void*)
: ::xml_schema::float_pskel (impl, 0),
  dutyCycle_impl_ (impl),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0)
{
}

// DispDutyCycle_pskel
//

void DispDutyCycle_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void DispDutyCycle_pskel::
dutyCycle_parser (::dutyCycle_pskel& p)
{
  this->dutyCycle_parser_ = &p;
}

void DispDutyCycle_pskel::
dispUnit_parser (::dispUnit2_pskel& p)
{
  this->dispUnit_parser_ = &p;
}

void DispDutyCycle_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::dutyCycle_pskel& dutyCycle,
         ::dispUnit2_pskel& dispUnit)
{
  this->id_parser_ = &id;
  this->dutyCycle_parser_ = &dutyCycle;
  this->dispUnit_parser_ = &dispUnit;
}

DispDutyCycle_pskel::
DispDutyCycle_pskel ()
: DispDutyCycle_impl_ (0),
  id_parser_ (0),
  dutyCycle_parser_ (0),
  dispUnit_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

DispDutyCycle_pskel::
DispDutyCycle_pskel (DispDutyCycle_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  DispDutyCycle_impl_ (impl),
  id_parser_ (0),
  dutyCycle_parser_ (0),
  dispUnit_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// dispUnit3_pskel
//

void dispUnit3_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void dispUnit3_pskel::
desc_parser (::xml_schema::string_pskel& p)
{
  this->desc_parser_ = &p;
}

void dispUnit3_pskel::
xpos_min_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_min_parser_ = &p;
}

void dispUnit3_pskel::
xpos_max_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_max_parser_ = &p;
}

void dispUnit3_pskel::
xcount_parser (::xml_schema::byte_pskel& p)
{
  this->xcount_parser_ = &p;
}

void dispUnit3_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::xml_schema::string_pskel& desc,
         ::xml_schema::byte_pskel& xpos_min,
         ::xml_schema::byte_pskel& xpos_max,
         ::xml_schema::byte_pskel& xcount)
{
  this->id_parser_ = &id;
  this->desc_parser_ = &desc;
  this->xpos_min_parser_ = &xpos_min;
  this->xpos_max_parser_ = &xpos_max;
  this->xcount_parser_ = &xcount;
}

dispUnit3_pskel::
dispUnit3_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  dispUnit3_impl_ (0),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0)
{
}

dispUnit3_pskel::
dispUnit3_pskel (dispUnit3_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  dispUnit3_impl_ (impl),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0)
{
}

// voltageValue_pskel
//

void voltageValue_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void voltageValue_pskel::
desc_parser (::xml_schema::string_pskel& p)
{
  this->desc_parser_ = &p;
}

void voltageValue_pskel::
xpos_min_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_min_parser_ = &p;
}

void voltageValue_pskel::
xpos_max_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_max_parser_ = &p;
}

void voltageValue_pskel::
xcount_parser (::xml_schema::byte_pskel& p)
{
  this->xcount_parser_ = &p;
}

void voltageValue_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::xml_schema::string_pskel& desc,
         ::xml_schema::byte_pskel& xpos_min,
         ::xml_schema::byte_pskel& xpos_max,
         ::xml_schema::byte_pskel& xcount)
{
  this->id_parser_ = &id;
  this->desc_parser_ = &desc;
  this->xpos_min_parser_ = &xpos_min;
  this->xpos_max_parser_ = &xpos_max;
  this->xcount_parser_ = &xcount;
}

voltageValue_pskel::
voltageValue_pskel (::xml_schema::float_pskel* tiein)
: ::xml_schema::float_pskel (tiein, 0),
  voltageValue_impl_ (0),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0)
{
}

voltageValue_pskel::
voltageValue_pskel (voltageValue_pskel* impl, void*)
: ::xml_schema::float_pskel (impl, 0),
  voltageValue_impl_ (impl),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0)
{
}

// DispVoltage_pskel
//

void DispVoltage_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void DispVoltage_pskel::
voltageValue_parser (::voltageValue_pskel& p)
{
  this->voltageValue_parser_ = &p;
}

void DispVoltage_pskel::
dispUnit_parser (::dispUnit3_pskel& p)
{
  this->dispUnit_parser_ = &p;
}

void DispVoltage_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::voltageValue_pskel& voltageValue,
         ::dispUnit3_pskel& dispUnit)
{
  this->id_parser_ = &id;
  this->voltageValue_parser_ = &voltageValue;
  this->dispUnit_parser_ = &dispUnit;
}

DispVoltage_pskel::
DispVoltage_pskel ()
: DispVoltage_impl_ (0),
  id_parser_ (0),
  voltageValue_parser_ (0),
  dispUnit_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

DispVoltage_pskel::
DispVoltage_pskel (DispVoltage_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  DispVoltage_impl_ (impl),
  id_parser_ (0),
  voltageValue_parser_ (0),
  dispUnit_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// LCDCharacterLine_pskel
//

void LCDCharacterLine_pskel::
num_parser (::xml_schema::byte_pskel& p)
{
  this->num_parser_ = &p;
}

void LCDCharacterLine_pskel::
max_char_parser (::xml_schema::byte_pskel& p)
{
  this->max_char_parser_ = &p;
}

void LCDCharacterLine_pskel::
DispTitle_parser (::DispTitle_pskel& p)
{
  this->DispTitle_parser_ = &p;
}

void LCDCharacterLine_pskel::
textObj_parser (::textObj_pskel& p)
{
  this->textObj_parser_ = &p;
}

void LCDCharacterLine_pskel::
DispFrequency_parser (::DispFrequency_pskel& p)
{
  this->DispFrequency_parser_ = &p;
}

void LCDCharacterLine_pskel::
DispIdentifier_parser (::DispIdentifier_pskel& p)
{
  this->DispIdentifier_parser_ = &p;
}

void LCDCharacterLine_pskel::
DispDuration_parser (::DispDuration_pskel& p)
{
  this->DispDuration_parser_ = &p;
}

void LCDCharacterLine_pskel::
DispDutyCycle_parser (::DispDutyCycle_pskel& p)
{
  this->DispDutyCycle_parser_ = &p;
}

void LCDCharacterLine_pskel::
DispVoltage_parser (::DispVoltage_pskel& p)
{
  this->DispVoltage_parser_ = &p;
}

void LCDCharacterLine_pskel::
parsers (::xml_schema::byte_pskel& num,
         ::xml_schema::byte_pskel& max_char,
         ::DispTitle_pskel& DispTitle,
         ::textObj_pskel& textObj,
         ::DispFrequency_pskel& DispFrequency,
         ::DispIdentifier_pskel& DispIdentifier,
         ::DispDuration_pskel& DispDuration,
         ::DispDutyCycle_pskel& DispDutyCycle,
         ::DispVoltage_pskel& DispVoltage)
{
  this->num_parser_ = &num;
  this->max_char_parser_ = &max_char;
  this->DispTitle_parser_ = &DispTitle;
  this->textObj_parser_ = &textObj;
  this->DispFrequency_parser_ = &DispFrequency;
  this->DispIdentifier_parser_ = &DispIdentifier;
  this->DispDuration_parser_ = &DispDuration;
  this->DispDutyCycle_parser_ = &DispDutyCycle;
  this->DispVoltage_parser_ = &DispVoltage;
}

LCDCharacterLine_pskel::
LCDCharacterLine_pskel ()
: LCDCharacterLine_impl_ (0),
  num_parser_ (0),
  max_char_parser_ (0),
  DispTitle_parser_ (0),
  textObj_parser_ (0),
  DispFrequency_parser_ (0),
  DispIdentifier_parser_ (0),
  DispDuration_parser_ (0),
  DispDutyCycle_parser_ (0),
  DispVoltage_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

LCDCharacterLine_pskel::
LCDCharacterLine_pskel (LCDCharacterLine_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  LCDCharacterLine_impl_ (impl),
  num_parser_ (0),
  max_char_parser_ (0),
  DispTitle_parser_ (0),
  textObj_parser_ (0),
  DispFrequency_parser_ (0),
  DispIdentifier_parser_ (0),
  DispDuration_parser_ (0),
  DispDutyCycle_parser_ (0),
  DispVoltage_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// textObj1_pskel
//

void textObj1_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void textObj1_pskel::
desc_parser (::xml_schema::string_pskel& p)
{
  this->desc_parser_ = &p;
}

void textObj1_pskel::
xpos_min_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_min_parser_ = &p;
}

void textObj1_pskel::
xpos_max_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_max_parser_ = &p;
}

void textObj1_pskel::
xcount_parser (::xml_schema::byte_pskel& p)
{
  this->xcount_parser_ = &p;
}

void textObj1_pskel::
align_parser (::xml_schema::string_pskel& p)
{
  this->align_parser_ = &p;
}

void textObj1_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::xml_schema::string_pskel& desc,
         ::xml_schema::byte_pskel& xpos_min,
         ::xml_schema::byte_pskel& xpos_max,
         ::xml_schema::byte_pskel& xcount,
         ::xml_schema::string_pskel& align)
{
  this->id_parser_ = &id;
  this->desc_parser_ = &desc;
  this->xpos_min_parser_ = &xpos_min;
  this->xpos_max_parser_ = &xpos_max;
  this->xcount_parser_ = &xcount;
  this->align_parser_ = &align;
}

textObj1_pskel::
textObj1_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  textObj1_impl_ (0),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0),
  align_parser_ (0)
{
}

textObj1_pskel::
textObj1_pskel (textObj1_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  textObj1_impl_ (impl),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0),
  align_parser_ (0)
{
}

// DispTitle_pskel
//

void DispTitle_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void DispTitle_pskel::
textObj_parser (::textObj1_pskel& p)
{
  this->textObj_parser_ = &p;
}

void DispTitle_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::textObj1_pskel& textObj)
{
  this->id_parser_ = &id;
  this->textObj_parser_ = &textObj;
}

DispTitle_pskel::
DispTitle_pskel ()
: DispTitle_impl_ (0),
  id_parser_ (0),
  textObj_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

DispTitle_pskel::
DispTitle_pskel (DispTitle_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  DispTitle_impl_ (impl),
  id_parser_ (0),
  textObj_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// freqValue_pskel
//

void freqValue_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void freqValue_pskel::
desc_parser (::xml_schema::string_pskel& p)
{
  this->desc_parser_ = &p;
}

void freqValue_pskel::
xpos_min_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_min_parser_ = &p;
}

void freqValue_pskel::
xpos_max_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_max_parser_ = &p;
}

void freqValue_pskel::
xcount_parser (::xml_schema::byte_pskel& p)
{
  this->xcount_parser_ = &p;
}

void freqValue_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::xml_schema::string_pskel& desc,
         ::xml_schema::byte_pskel& xpos_min,
         ::xml_schema::byte_pskel& xpos_max,
         ::xml_schema::byte_pskel& xcount)
{
  this->id_parser_ = &id;
  this->desc_parser_ = &desc;
  this->xpos_min_parser_ = &xpos_min;
  this->xpos_max_parser_ = &xpos_max;
  this->xcount_parser_ = &xcount;
}

freqValue_pskel::
freqValue_pskel (::xml_schema::float_pskel* tiein)
: ::xml_schema::float_pskel (tiein, 0),
  freqValue_impl_ (0),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0)
{
}

freqValue_pskel::
freqValue_pskel (freqValue_pskel* impl, void*)
: ::xml_schema::float_pskel (impl, 0),
  freqValue_impl_ (impl),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0)
{
}

// dispUnit_pskel
//

void dispUnit_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void dispUnit_pskel::
desc_parser (::xml_schema::string_pskel& p)
{
  this->desc_parser_ = &p;
}

void dispUnit_pskel::
xpos_min_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_min_parser_ = &p;
}

void dispUnit_pskel::
xpos_max_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_max_parser_ = &p;
}

void dispUnit_pskel::
xcount_parser (::xml_schema::byte_pskel& p)
{
  this->xcount_parser_ = &p;
}

void dispUnit_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::xml_schema::string_pskel& desc,
         ::xml_schema::byte_pskel& xpos_min,
         ::xml_schema::byte_pskel& xpos_max,
         ::xml_schema::byte_pskel& xcount)
{
  this->id_parser_ = &id;
  this->desc_parser_ = &desc;
  this->xpos_min_parser_ = &xpos_min;
  this->xpos_max_parser_ = &xpos_max;
  this->xcount_parser_ = &xcount;
}

dispUnit_pskel::
dispUnit_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  dispUnit_impl_ (0),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0)
{
}

dispUnit_pskel::
dispUnit_pskel (dispUnit_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  dispUnit_impl_ (impl),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0)
{
}

// DispFrequency_pskel
//

void DispFrequency_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void DispFrequency_pskel::
desc_parser (::xml_schema::string_pskel& p)
{
  this->desc_parser_ = &p;
}

void DispFrequency_pskel::
xpos_min_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_min_parser_ = &p;
}

void DispFrequency_pskel::
xpos_max_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_max_parser_ = &p;
}

void DispFrequency_pskel::
xcount_parser (::xml_schema::byte_pskel& p)
{
  this->xcount_parser_ = &p;
}

void DispFrequency_pskel::
freqValue_parser (::freqValue_pskel& p)
{
  this->freqValue_parser_ = &p;
}

void DispFrequency_pskel::
unitPrefix_parser (::unitPrefix_pskel& p)
{
  this->unitPrefix_parser_ = &p;
}

void DispFrequency_pskel::
dispUnit_parser (::dispUnit_pskel& p)
{
  this->dispUnit_parser_ = &p;
}

void DispFrequency_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::xml_schema::string_pskel& desc,
         ::xml_schema::byte_pskel& xpos_min,
         ::xml_schema::byte_pskel& xpos_max,
         ::xml_schema::byte_pskel& xcount,
         ::freqValue_pskel& freqValue,
         ::unitPrefix_pskel& unitPrefix,
         ::dispUnit_pskel& dispUnit)
{
  this->id_parser_ = &id;
  this->desc_parser_ = &desc;
  this->xpos_min_parser_ = &xpos_min;
  this->xpos_max_parser_ = &xpos_max;
  this->xcount_parser_ = &xcount;
  this->freqValue_parser_ = &freqValue;
  this->unitPrefix_parser_ = &unitPrefix;
  this->dispUnit_parser_ = &dispUnit;
}

DispFrequency_pskel::
DispFrequency_pskel ()
: DispFrequency_impl_ (0),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0),
  freqValue_parser_ (0),
  unitPrefix_parser_ (0),
  dispUnit_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

DispFrequency_pskel::
DispFrequency_pskel (DispFrequency_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  DispFrequency_impl_ (impl),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0),
  freqValue_parser_ (0),
  unitPrefix_parser_ (0),
  dispUnit_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// prefix_pskel
//

void prefix_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void prefix_pskel::
desc_parser (::xml_schema::string_pskel& p)
{
  this->desc_parser_ = &p;
}

void prefix_pskel::
default_value_parser (::xml_schema::string_pskel& p)
{
  this->default_value_parser_ = &p;
}

void prefix_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::xml_schema::string_pskel& desc,
         ::xml_schema::string_pskel& default_value)
{
  this->id_parser_ = &id;
  this->desc_parser_ = &desc;
  this->default_value_parser_ = &default_value;
}

prefix_pskel::
prefix_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  prefix_impl_ (0),
  id_parser_ (0),
  desc_parser_ (0),
  default_value_parser_ (0)
{
}

prefix_pskel::
prefix_pskel (prefix_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  prefix_impl_ (impl),
  id_parser_ (0),
  desc_parser_ (0),
  default_value_parser_ (0)
{
}

// unitPrefix_pskel
//

void unitPrefix_pskel::
id_parser (::xml_schema::byte_pskel& p)
{
  this->id_parser_ = &p;
}

void unitPrefix_pskel::
desc_parser (::xml_schema::string_pskel& p)
{
  this->desc_parser_ = &p;
}

void unitPrefix_pskel::
xpos_min_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_min_parser_ = &p;
}

void unitPrefix_pskel::
xpos_max_parser (::xml_schema::byte_pskel& p)
{
  this->xpos_max_parser_ = &p;
}

void unitPrefix_pskel::
xcount_parser (::xml_schema::byte_pskel& p)
{
  this->xcount_parser_ = &p;
}

void unitPrefix_pskel::
mode_parser (::xml_schema::string_pskel& p)
{
  this->mode_parser_ = &p;
}

void unitPrefix_pskel::
selected_parser (::xml_schema::byte_pskel& p)
{
  this->selected_parser_ = &p;
}

void unitPrefix_pskel::
prefix_parser (::prefix_pskel& p)
{
  this->prefix_parser_ = &p;
}

void unitPrefix_pskel::
parsers (::xml_schema::byte_pskel& id,
         ::xml_schema::string_pskel& desc,
         ::xml_schema::byte_pskel& xpos_min,
         ::xml_schema::byte_pskel& xpos_max,
         ::xml_schema::byte_pskel& xcount,
         ::xml_schema::string_pskel& mode,
         ::xml_schema::byte_pskel& selected,
         ::prefix_pskel& prefix)
{
  this->id_parser_ = &id;
  this->desc_parser_ = &desc;
  this->xpos_min_parser_ = &xpos_min;
  this->xpos_max_parser_ = &xpos_max;
  this->xcount_parser_ = &xcount;
  this->mode_parser_ = &mode;
  this->selected_parser_ = &selected;
  this->prefix_parser_ = &prefix;
}

unitPrefix_pskel::
unitPrefix_pskel ()
: unitPrefix_impl_ (0),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0),
  mode_parser_ (0),
  selected_parser_ (0),
  prefix_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

unitPrefix_pskel::
unitPrefix_pskel (unitPrefix_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  unitPrefix_impl_ (impl),
  id_parser_ (0),
  desc_parser_ (0),
  xpos_min_parser_ (0),
  xpos_max_parser_ (0),
  xcount_parser_ (0),
  mode_parser_ (0),
  selected_parser_ (0),
  prefix_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

#include <assert.h>

// UIXConfig_pskel
//

void UIXConfig_pskel::
locale (const ::std::string& x)
{
  if (this->UIXConfig_impl_)
    this->UIXConfig_impl_->locale (x);
}

void UIXConfig_pskel::
ApplicationStates (::ApplicationStates* x)
{
  if (this->UIXConfig_impl_)
    this->UIXConfig_impl_->ApplicationStates (x);
}

void UIXConfig_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  if (this->locale_parser_)
    this->locale_parser_->_reset ();

  this->resetting_ = true;

  if (this->ApplicationStates_parser_)
    this->ApplicationStates_parser_->_reset ();

  this->resetting_ = false;
}

// ApplicationStates_pskel
//

void ApplicationStates_pskel::
AppState (::AppState* x)
{
  if (this->ApplicationStates_impl_)
    this->ApplicationStates_impl_->AppState (x);
}

void ApplicationStates_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->AppState_parser_)
    this->AppState_parser_->_reset ();

  this->resetting_ = false;
}

// AppState_pskel
//

void AppState_pskel::
id (signed char x)
{
  if (this->AppState_impl_)
    this->AppState_impl_->id (x);
}

void AppState_pskel::
name (const ::std::string& x)
{
  if (this->AppState_impl_)
    this->AppState_impl_->name (x);
}

void AppState_pskel::
desc (const ::std::string& x)
{
  if (this->AppState_impl_)
    this->AppState_impl_->desc (x);
}

void AppState_pskel::
AppModes (::AppModes* x)
{
  if (this->AppState_impl_)
    this->AppState_impl_->AppModes (x);
}

void AppState_pskel::
ScreenObjects (::ScreenObjects* x)
{
  if (this->AppState_impl_)
    this->AppState_impl_->ScreenObjects (x);
}

void AppState_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->name_parser_)
    this->name_parser_->_reset ();

  if (this->desc_parser_)
    this->desc_parser_->_reset ();

  this->resetting_ = true;

  if (this->AppModes_parser_)
    this->AppModes_parser_->_reset ();

  if (this->ScreenObjects_parser_)
    this->ScreenObjects_parser_->_reset ();

  this->resetting_ = false;
}

// mode_pskel
//

void mode_pskel::
id (signed char x)
{
  if (this->mode_impl_)
    this->mode_impl_->id (x);
}

void mode_pskel::
desc (const ::std::string& x)
{
  if (this->mode_impl_)
    this->mode_impl_->desc (x);
}

void mode_pskel::
_reset ()
{
  typedef ::xml_schema::byte_pskel base;
  base::_reset ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->desc_parser_)
    this->desc_parser_->_reset ();
}

signed char mode_pskel::
post_byte ()
{
  assert (this->byte_impl_);
  return this->byte_impl_->post_byte ();
}

// AppModes_pskel
//

void AppModes_pskel::
mode (const ::mode& x)
{
  if (this->AppModes_impl_)
    this->AppModes_impl_->mode (x);
}

void AppModes_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->mode_parser_)
    this->mode_parser_->_reset ();

  this->resetting_ = false;
}

// ScreenObjects_pskel
//

void ScreenObjects_pskel::
LCDCharacterLine (::LCDCharacterLine* x)
{
  if (this->ScreenObjects_impl_)
    this->ScreenObjects_impl_->LCDCharacterLine (x);
}

void ScreenObjects_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->LCDCharacterLine_parser_)
    this->LCDCharacterLine_parser_->_reset ();

  this->resetting_ = false;
}

// textObj_pskel
//

void textObj_pskel::
id (signed char x)
{
  if (this->textObj_impl_)
    this->textObj_impl_->id (x);
}

void textObj_pskel::
desc (const ::std::string& x)
{
  if (this->textObj_impl_)
    this->textObj_impl_->desc (x);
}

void textObj_pskel::
xpos_min (signed char x)
{
  if (this->textObj_impl_)
    this->textObj_impl_->xpos_min (x);
}

void textObj_pskel::
xpos_max (signed char x)
{
  if (this->textObj_impl_)
    this->textObj_impl_->xpos_max (x);
}

void textObj_pskel::
xcount (signed char x)
{
  if (this->textObj_impl_)
    this->textObj_impl_->xcount (x);
}

void textObj_pskel::
align (const ::std::string& x)
{
  if (this->textObj_impl_)
    this->textObj_impl_->align (x);
}

void textObj_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->desc_parser_)
    this->desc_parser_->_reset ();

  if (this->xpos_min_parser_)
    this->xpos_min_parser_->_reset ();

  if (this->xpos_max_parser_)
    this->xpos_max_parser_->_reset ();

  if (this->xcount_parser_)
    this->xcount_parser_->_reset ();

  if (this->align_parser_)
    this->align_parser_->_reset ();
}

::std::string textObj_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// durationValue_pskel
//

void durationValue_pskel::
id (signed char x)
{
  if (this->durationValue_impl_)
    this->durationValue_impl_->id (x);
}

void durationValue_pskel::
desc (const ::std::string& x)
{
  if (this->durationValue_impl_)
    this->durationValue_impl_->desc (x);
}

void durationValue_pskel::
xpos_min (signed char x)
{
  if (this->durationValue_impl_)
    this->durationValue_impl_->xpos_min (x);
}

void durationValue_pskel::
xpos_max (signed char x)
{
  if (this->durationValue_impl_)
    this->durationValue_impl_->xpos_max (x);
}

void durationValue_pskel::
xcount (signed char x)
{
  if (this->durationValue_impl_)
    this->durationValue_impl_->xcount (x);
}

void durationValue_pskel::
_reset ()
{
  typedef ::xml_schema::byte_pskel base;
  base::_reset ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->desc_parser_)
    this->desc_parser_->_reset ();

  if (this->xpos_min_parser_)
    this->xpos_min_parser_->_reset ();

  if (this->xpos_max_parser_)
    this->xpos_max_parser_->_reset ();

  if (this->xcount_parser_)
    this->xcount_parser_->_reset ();
}

signed char durationValue_pskel::
post_byte ()
{
  assert (this->byte_impl_);
  return this->byte_impl_->post_byte ();
}

// dispUnit1_pskel
//

void dispUnit1_pskel::
id (signed char x)
{
  if (this->dispUnit1_impl_)
    this->dispUnit1_impl_->id (x);
}

void dispUnit1_pskel::
desc (const ::std::string& x)
{
  if (this->dispUnit1_impl_)
    this->dispUnit1_impl_->desc (x);
}

void dispUnit1_pskel::
xpos_min (signed char x)
{
  if (this->dispUnit1_impl_)
    this->dispUnit1_impl_->xpos_min (x);
}

void dispUnit1_pskel::
xpos_max (signed char x)
{
  if (this->dispUnit1_impl_)
    this->dispUnit1_impl_->xpos_max (x);
}

void dispUnit1_pskel::
xcount (signed char x)
{
  if (this->dispUnit1_impl_)
    this->dispUnit1_impl_->xcount (x);
}

void dispUnit1_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->desc_parser_)
    this->desc_parser_->_reset ();

  if (this->xpos_min_parser_)
    this->xpos_min_parser_->_reset ();

  if (this->xpos_max_parser_)
    this->xpos_max_parser_->_reset ();

  if (this->xcount_parser_)
    this->xcount_parser_->_reset ();
}

::std::string dispUnit1_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// DispDuration_pskel
//

void DispDuration_pskel::
id (signed char x)
{
  if (this->DispDuration_impl_)
    this->DispDuration_impl_->id (x);
}

void DispDuration_pskel::
durationValue (const ::durationValue& x)
{
  if (this->DispDuration_impl_)
    this->DispDuration_impl_->durationValue (x);
}

void DispDuration_pskel::
dispUnit (const ::dispUnit1& x)
{
  if (this->DispDuration_impl_)
    this->DispDuration_impl_->dispUnit (x);
}

void DispDuration_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  this->resetting_ = true;

  if (this->durationValue_parser_)
    this->durationValue_parser_->_reset ();

  if (this->dispUnit_parser_)
    this->dispUnit_parser_->_reset ();

  this->resetting_ = false;
}

// DispIdentifier_pskel
//

void DispIdentifier_pskel::
id (signed char x)
{
  if (this->DispIdentifier_impl_)
    this->DispIdentifier_impl_->id (x);
}

void DispIdentifier_pskel::
desc (const ::std::string& x)
{
  if (this->DispIdentifier_impl_)
    this->DispIdentifier_impl_->desc (x);
}

void DispIdentifier_pskel::
xpos_min (signed char x)
{
  if (this->DispIdentifier_impl_)
    this->DispIdentifier_impl_->xpos_min (x);
}

void DispIdentifier_pskel::
xpos_max (signed char x)
{
  if (this->DispIdentifier_impl_)
    this->DispIdentifier_impl_->xpos_max (x);
}

void DispIdentifier_pskel::
xcount (signed char x)
{
  if (this->DispIdentifier_impl_)
    this->DispIdentifier_impl_->xcount (x);
}

void DispIdentifier_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->desc_parser_)
    this->desc_parser_->_reset ();

  if (this->xpos_min_parser_)
    this->xpos_min_parser_->_reset ();

  if (this->xpos_max_parser_)
    this->xpos_max_parser_->_reset ();

  if (this->xcount_parser_)
    this->xcount_parser_->_reset ();
}

::std::string DispIdentifier_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// dispUnit2_pskel
//

void dispUnit2_pskel::
id (signed char x)
{
  if (this->dispUnit2_impl_)
    this->dispUnit2_impl_->id (x);
}

void dispUnit2_pskel::
desc (const ::std::string& x)
{
  if (this->dispUnit2_impl_)
    this->dispUnit2_impl_->desc (x);
}

void dispUnit2_pskel::
xpos_min (signed char x)
{
  if (this->dispUnit2_impl_)
    this->dispUnit2_impl_->xpos_min (x);
}

void dispUnit2_pskel::
xpos_max (signed char x)
{
  if (this->dispUnit2_impl_)
    this->dispUnit2_impl_->xpos_max (x);
}

void dispUnit2_pskel::
xcount (signed char x)
{
  if (this->dispUnit2_impl_)
    this->dispUnit2_impl_->xcount (x);
}

void dispUnit2_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->desc_parser_)
    this->desc_parser_->_reset ();

  if (this->xpos_min_parser_)
    this->xpos_min_parser_->_reset ();

  if (this->xpos_max_parser_)
    this->xpos_max_parser_->_reset ();

  if (this->xcount_parser_)
    this->xcount_parser_->_reset ();
}

::std::string dispUnit2_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// dutyCycle_pskel
//

void dutyCycle_pskel::
id (signed char x)
{
  if (this->dutyCycle_impl_)
    this->dutyCycle_impl_->id (x);
}

void dutyCycle_pskel::
desc (const ::std::string& x)
{
  if (this->dutyCycle_impl_)
    this->dutyCycle_impl_->desc (x);
}

void dutyCycle_pskel::
xpos_min (signed char x)
{
  if (this->dutyCycle_impl_)
    this->dutyCycle_impl_->xpos_min (x);
}

void dutyCycle_pskel::
xpos_max (signed char x)
{
  if (this->dutyCycle_impl_)
    this->dutyCycle_impl_->xpos_max (x);
}

void dutyCycle_pskel::
xcount (signed char x)
{
  if (this->dutyCycle_impl_)
    this->dutyCycle_impl_->xcount (x);
}

void dutyCycle_pskel::
_reset ()
{
  typedef ::xml_schema::float_pskel base;
  base::_reset ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->desc_parser_)
    this->desc_parser_->_reset ();

  if (this->xpos_min_parser_)
    this->xpos_min_parser_->_reset ();

  if (this->xpos_max_parser_)
    this->xpos_max_parser_->_reset ();

  if (this->xcount_parser_)
    this->xcount_parser_->_reset ();
}

float dutyCycle_pskel::
post_float ()
{
  assert (this->float_impl_);
  return this->float_impl_->post_float ();
}

// DispDutyCycle_pskel
//

void DispDutyCycle_pskel::
id (signed char x)
{
  if (this->DispDutyCycle_impl_)
    this->DispDutyCycle_impl_->id (x);
}

void DispDutyCycle_pskel::
dutyCycle (const ::dutyCycle& x)
{
  if (this->DispDutyCycle_impl_)
    this->DispDutyCycle_impl_->dutyCycle (x);
}

void DispDutyCycle_pskel::
dispUnit (const ::dispUnit2& x)
{
  if (this->DispDutyCycle_impl_)
    this->DispDutyCycle_impl_->dispUnit (x);
}

void DispDutyCycle_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  this->resetting_ = true;

  if (this->dutyCycle_parser_)
    this->dutyCycle_parser_->_reset ();

  if (this->dispUnit_parser_)
    this->dispUnit_parser_->_reset ();

  this->resetting_ = false;
}

// dispUnit3_pskel
//

void dispUnit3_pskel::
id (signed char x)
{
  if (this->dispUnit3_impl_)
    this->dispUnit3_impl_->id (x);
}

void dispUnit3_pskel::
desc (const ::std::string& x)
{
  if (this->dispUnit3_impl_)
    this->dispUnit3_impl_->desc (x);
}

void dispUnit3_pskel::
xpos_min (signed char x)
{
  if (this->dispUnit3_impl_)
    this->dispUnit3_impl_->xpos_min (x);
}

void dispUnit3_pskel::
xpos_max (signed char x)
{
  if (this->dispUnit3_impl_)
    this->dispUnit3_impl_->xpos_max (x);
}

void dispUnit3_pskel::
xcount (signed char x)
{
  if (this->dispUnit3_impl_)
    this->dispUnit3_impl_->xcount (x);
}

void dispUnit3_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->desc_parser_)
    this->desc_parser_->_reset ();

  if (this->xpos_min_parser_)
    this->xpos_min_parser_->_reset ();

  if (this->xpos_max_parser_)
    this->xpos_max_parser_->_reset ();

  if (this->xcount_parser_)
    this->xcount_parser_->_reset ();
}

::std::string dispUnit3_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// voltageValue_pskel
//

void voltageValue_pskel::
id (signed char x)
{
  if (this->voltageValue_impl_)
    this->voltageValue_impl_->id (x);
}

void voltageValue_pskel::
desc (const ::std::string& x)
{
  if (this->voltageValue_impl_)
    this->voltageValue_impl_->desc (x);
}

void voltageValue_pskel::
xpos_min (signed char x)
{
  if (this->voltageValue_impl_)
    this->voltageValue_impl_->xpos_min (x);
}

void voltageValue_pskel::
xpos_max (signed char x)
{
  if (this->voltageValue_impl_)
    this->voltageValue_impl_->xpos_max (x);
}

void voltageValue_pskel::
xcount (signed char x)
{
  if (this->voltageValue_impl_)
    this->voltageValue_impl_->xcount (x);
}

void voltageValue_pskel::
_reset ()
{
  typedef ::xml_schema::float_pskel base;
  base::_reset ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->desc_parser_)
    this->desc_parser_->_reset ();

  if (this->xpos_min_parser_)
    this->xpos_min_parser_->_reset ();

  if (this->xpos_max_parser_)
    this->xpos_max_parser_->_reset ();

  if (this->xcount_parser_)
    this->xcount_parser_->_reset ();
}

float voltageValue_pskel::
post_float ()
{
  assert (this->float_impl_);
  return this->float_impl_->post_float ();
}

// DispVoltage_pskel
//

void DispVoltage_pskel::
id (signed char x)
{
  if (this->DispVoltage_impl_)
    this->DispVoltage_impl_->id (x);
}

void DispVoltage_pskel::
voltageValue (const ::voltageValue& x)
{
  if (this->DispVoltage_impl_)
    this->DispVoltage_impl_->voltageValue (x);
}

void DispVoltage_pskel::
dispUnit (const ::dispUnit3& x)
{
  if (this->DispVoltage_impl_)
    this->DispVoltage_impl_->dispUnit (x);
}

void DispVoltage_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  this->resetting_ = true;

  if (this->voltageValue_parser_)
    this->voltageValue_parser_->_reset ();

  if (this->dispUnit_parser_)
    this->dispUnit_parser_->_reset ();

  this->resetting_ = false;
}

// LCDCharacterLine_pskel
//

void LCDCharacterLine_pskel::
num (signed char x)
{
  if (this->LCDCharacterLine_impl_)
    this->LCDCharacterLine_impl_->num (x);
}

void LCDCharacterLine_pskel::
max_char (signed char x)
{
  if (this->LCDCharacterLine_impl_)
    this->LCDCharacterLine_impl_->max_char (x);
}

void LCDCharacterLine_pskel::
choice_arm (choice_arm_tag x)
{
  if (this->LCDCharacterLine_impl_)
    this->LCDCharacterLine_impl_->choice_arm (x);
}

void LCDCharacterLine_pskel::
DispTitle (::DispTitle* x)
{
  if (this->LCDCharacterLine_impl_)
    this->LCDCharacterLine_impl_->DispTitle (x);
}

void LCDCharacterLine_pskel::
textObj (const ::textObj& x)
{
  if (this->LCDCharacterLine_impl_)
    this->LCDCharacterLine_impl_->textObj (x);
}

void LCDCharacterLine_pskel::
DispFrequency (::DispFrequency* x)
{
  if (this->LCDCharacterLine_impl_)
    this->LCDCharacterLine_impl_->DispFrequency (x);
}

void LCDCharacterLine_pskel::
DispIdentifier (const ::DispIdentifier& x)
{
  if (this->LCDCharacterLine_impl_)
    this->LCDCharacterLine_impl_->DispIdentifier (x);
}

void LCDCharacterLine_pskel::
DispDuration (const ::DispDuration& x)
{
  if (this->LCDCharacterLine_impl_)
    this->LCDCharacterLine_impl_->DispDuration (x);
}

void LCDCharacterLine_pskel::
DispDutyCycle (const ::DispDutyCycle& x)
{
  if (this->LCDCharacterLine_impl_)
    this->LCDCharacterLine_impl_->DispDutyCycle (x);
}

void LCDCharacterLine_pskel::
DispVoltage (const ::DispVoltage& x)
{
  if (this->LCDCharacterLine_impl_)
    this->LCDCharacterLine_impl_->DispVoltage (x);
}

void LCDCharacterLine_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  if (this->num_parser_)
    this->num_parser_->_reset ();

  if (this->max_char_parser_)
    this->max_char_parser_->_reset ();

  this->resetting_ = true;

  if (this->DispTitle_parser_)
    this->DispTitle_parser_->_reset ();

  if (this->textObj_parser_)
    this->textObj_parser_->_reset ();

  if (this->DispFrequency_parser_)
    this->DispFrequency_parser_->_reset ();

  if (this->DispIdentifier_parser_)
    this->DispIdentifier_parser_->_reset ();

  if (this->DispDuration_parser_)
    this->DispDuration_parser_->_reset ();

  if (this->DispDutyCycle_parser_)
    this->DispDutyCycle_parser_->_reset ();

  if (this->DispVoltage_parser_)
    this->DispVoltage_parser_->_reset ();

  this->resetting_ = false;
}

// textObj1_pskel
//

void textObj1_pskel::
id (signed char x)
{
  if (this->textObj1_impl_)
    this->textObj1_impl_->id (x);
}

void textObj1_pskel::
desc (const ::std::string& x)
{
  if (this->textObj1_impl_)
    this->textObj1_impl_->desc (x);
}

void textObj1_pskel::
xpos_min (signed char x)
{
  if (this->textObj1_impl_)
    this->textObj1_impl_->xpos_min (x);
}

void textObj1_pskel::
xpos_max (signed char x)
{
  if (this->textObj1_impl_)
    this->textObj1_impl_->xpos_max (x);
}

void textObj1_pskel::
xcount (signed char x)
{
  if (this->textObj1_impl_)
    this->textObj1_impl_->xcount (x);
}

void textObj1_pskel::
align (const ::std::string& x)
{
  if (this->textObj1_impl_)
    this->textObj1_impl_->align (x);
}

void textObj1_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->desc_parser_)
    this->desc_parser_->_reset ();

  if (this->xpos_min_parser_)
    this->xpos_min_parser_->_reset ();

  if (this->xpos_max_parser_)
    this->xpos_max_parser_->_reset ();

  if (this->xcount_parser_)
    this->xcount_parser_->_reset ();

  if (this->align_parser_)
    this->align_parser_->_reset ();
}

::std::string textObj1_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// DispTitle_pskel
//

void DispTitle_pskel::
id (signed char x)
{
  if (this->DispTitle_impl_)
    this->DispTitle_impl_->id (x);
}

void DispTitle_pskel::
textObj (const ::textObj1& x)
{
  if (this->DispTitle_impl_)
    this->DispTitle_impl_->textObj (x);
}

void DispTitle_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  this->resetting_ = true;

  if (this->textObj_parser_)
    this->textObj_parser_->_reset ();

  this->resetting_ = false;
}

// freqValue_pskel
//

void freqValue_pskel::
id (signed char x)
{
  if (this->freqValue_impl_)
    this->freqValue_impl_->id (x);
}

void freqValue_pskel::
desc (const ::std::string& x)
{
  if (this->freqValue_impl_)
    this->freqValue_impl_->desc (x);
}

void freqValue_pskel::
xpos_min (signed char x)
{
  if (this->freqValue_impl_)
    this->freqValue_impl_->xpos_min (x);
}

void freqValue_pskel::
xpos_max (signed char x)
{
  if (this->freqValue_impl_)
    this->freqValue_impl_->xpos_max (x);
}

void freqValue_pskel::
xcount (signed char x)
{
  if (this->freqValue_impl_)
    this->freqValue_impl_->xcount (x);
}

void freqValue_pskel::
_reset ()
{
  typedef ::xml_schema::float_pskel base;
  base::_reset ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->desc_parser_)
    this->desc_parser_->_reset ();

  if (this->xpos_min_parser_)
    this->xpos_min_parser_->_reset ();

  if (this->xpos_max_parser_)
    this->xpos_max_parser_->_reset ();

  if (this->xcount_parser_)
    this->xcount_parser_->_reset ();
}

float freqValue_pskel::
post_float ()
{
  assert (this->float_impl_);
  return this->float_impl_->post_float ();
}

// dispUnit_pskel
//

void dispUnit_pskel::
id (signed char x)
{
  if (this->dispUnit_impl_)
    this->dispUnit_impl_->id (x);
}

void dispUnit_pskel::
desc (const ::std::string& x)
{
  if (this->dispUnit_impl_)
    this->dispUnit_impl_->desc (x);
}

void dispUnit_pskel::
xpos_min (signed char x)
{
  if (this->dispUnit_impl_)
    this->dispUnit_impl_->xpos_min (x);
}

void dispUnit_pskel::
xpos_max (signed char x)
{
  if (this->dispUnit_impl_)
    this->dispUnit_impl_->xpos_max (x);
}

void dispUnit_pskel::
xcount (signed char x)
{
  if (this->dispUnit_impl_)
    this->dispUnit_impl_->xcount (x);
}

void dispUnit_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->desc_parser_)
    this->desc_parser_->_reset ();

  if (this->xpos_min_parser_)
    this->xpos_min_parser_->_reset ();

  if (this->xpos_max_parser_)
    this->xpos_max_parser_->_reset ();

  if (this->xcount_parser_)
    this->xcount_parser_->_reset ();
}

::std::string dispUnit_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// DispFrequency_pskel
//

void DispFrequency_pskel::
id (signed char x)
{
  if (this->DispFrequency_impl_)
    this->DispFrequency_impl_->id (x);
}

void DispFrequency_pskel::
desc (const ::std::string& x)
{
  if (this->DispFrequency_impl_)
    this->DispFrequency_impl_->desc (x);
}

void DispFrequency_pskel::
xpos_min (signed char x)
{
  if (this->DispFrequency_impl_)
    this->DispFrequency_impl_->xpos_min (x);
}

void DispFrequency_pskel::
xpos_max (signed char x)
{
  if (this->DispFrequency_impl_)
    this->DispFrequency_impl_->xpos_max (x);
}

void DispFrequency_pskel::
xcount (signed char x)
{
  if (this->DispFrequency_impl_)
    this->DispFrequency_impl_->xcount (x);
}

void DispFrequency_pskel::
freqValue (const ::freqValue& x)
{
  if (this->DispFrequency_impl_)
    this->DispFrequency_impl_->freqValue (x);
}

void DispFrequency_pskel::
unitPrefix (::unitPrefix* x)
{
  if (this->DispFrequency_impl_)
    this->DispFrequency_impl_->unitPrefix (x);
}

void DispFrequency_pskel::
dispUnit (const ::dispUnit& x)
{
  if (this->DispFrequency_impl_)
    this->DispFrequency_impl_->dispUnit (x);
}

void DispFrequency_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->desc_parser_)
    this->desc_parser_->_reset ();

  if (this->xpos_min_parser_)
    this->xpos_min_parser_->_reset ();

  if (this->xpos_max_parser_)
    this->xpos_max_parser_->_reset ();

  if (this->xcount_parser_)
    this->xcount_parser_->_reset ();

  this->resetting_ = true;

  if (this->freqValue_parser_)
    this->freqValue_parser_->_reset ();

  if (this->unitPrefix_parser_)
    this->unitPrefix_parser_->_reset ();

  if (this->dispUnit_parser_)
    this->dispUnit_parser_->_reset ();

  this->resetting_ = false;
}

// prefix_pskel
//

void prefix_pskel::
id (signed char x)
{
  if (this->prefix_impl_)
    this->prefix_impl_->id (x);
}

void prefix_pskel::
desc (const ::std::string& x)
{
  if (this->prefix_impl_)
    this->prefix_impl_->desc (x);
}

void prefix_pskel::
default_value (const ::std::string& x)
{
  if (this->prefix_impl_)
    this->prefix_impl_->default_value (x);
}

void prefix_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->desc_parser_)
    this->desc_parser_->_reset ();

  if (this->default_value_parser_)
    this->default_value_parser_->_reset ();
}

::std::string prefix_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// unitPrefix_pskel
//

void unitPrefix_pskel::
id (signed char x)
{
  if (this->unitPrefix_impl_)
    this->unitPrefix_impl_->id (x);
}

void unitPrefix_pskel::
desc (const ::std::string& x)
{
  if (this->unitPrefix_impl_)
    this->unitPrefix_impl_->desc (x);
}

void unitPrefix_pskel::
xpos_min (signed char x)
{
  if (this->unitPrefix_impl_)
    this->unitPrefix_impl_->xpos_min (x);
}

void unitPrefix_pskel::
xpos_max (signed char x)
{
  if (this->unitPrefix_impl_)
    this->unitPrefix_impl_->xpos_max (x);
}

void unitPrefix_pskel::
xcount (signed char x)
{
  if (this->unitPrefix_impl_)
    this->unitPrefix_impl_->xcount (x);
}

void unitPrefix_pskel::
mode (const ::std::string& x)
{
  if (this->unitPrefix_impl_)
    this->unitPrefix_impl_->mode (x);
}

void unitPrefix_pskel::
selected (signed char x)
{
  if (this->unitPrefix_impl_)
    this->unitPrefix_impl_->selected (x);
}

void unitPrefix_pskel::
prefix (const ::prefix& x)
{
  if (this->unitPrefix_impl_)
    this->unitPrefix_impl_->prefix (x);
}

void unitPrefix_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->desc_parser_)
    this->desc_parser_->_reset ();

  if (this->xpos_min_parser_)
    this->xpos_min_parser_->_reset ();

  if (this->xpos_max_parser_)
    this->xpos_max_parser_->_reset ();

  if (this->xcount_parser_)
    this->xcount_parser_->_reset ();

  if (this->mode_parser_)
    this->mode_parser_->_reset ();

  if (this->selected_parser_)
    this->selected_parser_->_reset ();

  this->resetting_ = true;

  if (this->prefix_parser_)
    this->prefix_parser_->_reset ();

  this->resetting_ = false;
}

#include <assert.h>

// Element validation and dispatch functions for UIXConfig_pskel.
//
bool UIXConfig_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "ApplicationStates" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &UIXConfig_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool UIXConfig_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void UIXConfig_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void UIXConfig_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void UIXConfig_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "ApplicationStates" && ns.empty ())
      {
        if (start)
        {
          if (this->ApplicationStates_parser_)
          {
            this->ApplicationStates_parser_->pre ();
            ctx.nested_parser (this->ApplicationStates_parser_);
          }
        }
        else
        {
          if (this->ApplicationStates_parser_ != 0)
          {
            ::ApplicationStates* tmp = this->ApplicationStates_parser_->post_ApplicationStates ();
            this->ApplicationStates (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for ApplicationStates_pskel.
//
bool ApplicationStates_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "AppState" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ApplicationStates_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ApplicationStates_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ApplicationStates_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ApplicationStates_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void ApplicationStates_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "AppState" && ns.empty ())
      {
        if (start)
        {
          if (this->AppState_parser_)
          {
            this->AppState_parser_->pre ();
            ctx.nested_parser (this->AppState_parser_);
          }
        }
        else
        {
          if (this->AppState_parser_ != 0)
          {
            ::AppState* tmp = this->AppState_parser_->post_AppState ();
            this->AppState (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for AppState_pskel.
//
bool AppState_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "AppModes" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &AppState_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool AppState_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void AppState_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void AppState_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void AppState_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "AppModes" && ns.empty ())
      {
        if (start)
        {
          if (this->AppModes_parser_)
          {
            this->AppModes_parser_->pre ();
            ctx.nested_parser (this->AppModes_parser_);
          }
        }
        else
        {
          if (this->AppModes_parser_ != 0)
          {
            ::AppModes* tmp = this->AppModes_parser_->post_AppModes ();
            this->AppModes (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "ScreenObjects" && ns.empty ())
      {
        if (start)
        {
          if (this->ScreenObjects_parser_)
          {
            this->ScreenObjects_parser_->pre ();
            ctx.nested_parser (this->ScreenObjects_parser_);
          }
        }
        else
        {
          if (this->ScreenObjects_parser_ != 0)
          {
            ::ScreenObjects* tmp = this->ScreenObjects_parser_->post_ScreenObjects ();
            this->ScreenObjects (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for AppModes_pskel.
//
bool AppModes_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "mode" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &AppModes_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool AppModes_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void AppModes_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void AppModes_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void AppModes_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "mode" && ns.empty ())
      {
        if (start)
        {
          if (this->mode_parser_)
          {
            this->mode_parser_->pre ();
            ctx.nested_parser (this->mode_parser_);
          }
        }
        else
        {
          if (this->mode_parser_ != 0)
          {
            const ::mode& tmp = this->mode_parser_->post_mode ();
            this->mode (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for ScreenObjects_pskel.
//
bool ScreenObjects_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "LCDCharacterLine" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ScreenObjects_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ScreenObjects_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ScreenObjects_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ScreenObjects_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ScreenObjects_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "LCDCharacterLine" && ns.empty ())
      {
        if (start)
        {
          if (this->LCDCharacterLine_parser_)
          {
            this->LCDCharacterLine_parser_->pre ();
            ctx.nested_parser (this->LCDCharacterLine_parser_);
          }
        }
        else
        {
          if (this->LCDCharacterLine_parser_ != 0)
          {
            ::LCDCharacterLine* tmp = this->LCDCharacterLine_parser_->post_LCDCharacterLine ();
            this->LCDCharacterLine (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for DispDuration_pskel.
//
bool DispDuration_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "durationValue" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &DispDuration_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool DispDuration_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void DispDuration_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void DispDuration_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void DispDuration_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "durationValue" && ns.empty ())
      {
        if (start)
        {
          if (this->durationValue_parser_)
          {
            this->durationValue_parser_->pre ();
            ctx.nested_parser (this->durationValue_parser_);
          }
        }
        else
        {
          if (this->durationValue_parser_ != 0)
          {
            const ::durationValue& tmp = this->durationValue_parser_->post_durationValue ();
            this->durationValue (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "dispUnit" && ns.empty ())
      {
        if (start)
        {
          if (this->dispUnit_parser_)
          {
            this->dispUnit_parser_->pre ();
            ctx.nested_parser (this->dispUnit_parser_);
          }
        }
        else
        {
          if (this->dispUnit_parser_ != 0)
          {
            const ::dispUnit1& tmp = this->dispUnit_parser_->post_dispUnit1 ();
            this->dispUnit (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for DispDutyCycle_pskel.
//
bool DispDutyCycle_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "dutyCycle" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &DispDutyCycle_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool DispDutyCycle_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void DispDutyCycle_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void DispDutyCycle_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void DispDutyCycle_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "dutyCycle" && ns.empty ())
      {
        if (start)
        {
          if (this->dutyCycle_parser_)
          {
            this->dutyCycle_parser_->pre ();
            ctx.nested_parser (this->dutyCycle_parser_);
          }
        }
        else
        {
          if (this->dutyCycle_parser_ != 0)
          {
            const ::dutyCycle& tmp = this->dutyCycle_parser_->post_dutyCycle ();
            this->dutyCycle (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "dispUnit" && ns.empty ())
      {
        if (start)
        {
          if (this->dispUnit_parser_)
          {
            this->dispUnit_parser_->pre ();
            ctx.nested_parser (this->dispUnit_parser_);
          }
        }
        else
        {
          if (this->dispUnit_parser_ != 0)
          {
            const ::dispUnit2& tmp = this->dispUnit_parser_->post_dispUnit2 ();
            this->dispUnit (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for DispVoltage_pskel.
//
bool DispVoltage_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "voltageValue" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &DispVoltage_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool DispVoltage_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void DispVoltage_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void DispVoltage_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void DispVoltage_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "voltageValue" && ns.empty ())
      {
        if (start)
        {
          if (this->voltageValue_parser_)
          {
            this->voltageValue_parser_->pre ();
            ctx.nested_parser (this->voltageValue_parser_);
          }
        }
        else
        {
          if (this->voltageValue_parser_ != 0)
          {
            const ::voltageValue& tmp = this->voltageValue_parser_->post_voltageValue ();
            this->voltageValue (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "dispUnit" && ns.empty ())
      {
        if (start)
        {
          if (this->dispUnit_parser_)
          {
            this->dispUnit_parser_->pre ();
            ctx.nested_parser (this->dispUnit_parser_);
          }
        }
        else
        {
          if (this->dispUnit_parser_ != 0)
          {
            const ::dispUnit3& tmp = this->dispUnit_parser_->post_dispUnit3 ();
            this->dispUnit (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for LCDCharacterLine_pskel.
//
bool LCDCharacterLine_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "DispTitle" && ns.empty ())
        s = 0UL;
      else if (n == "textObj" && ns.empty ())
        s = 1UL;
      else if (n == "DispFrequency" && ns.empty ())
        s = 2UL;
      else if (n == "DispIdentifier" && ns.empty ())
        s = 3UL;
      else if (n == "DispDuration" && ns.empty ())
        s = 4UL;
      else if (n == "DispDutyCycle" && ns.empty ())
        s = 5UL;
      else if (n == "DispVoltage" && ns.empty ())
        s = 6UL;

      if (s != ~0UL)
      {
        vd->count++;

        vd = vs.data + vs.size++;
        vd->func = &LCDCharacterLine_pskel::choice_0;
        vd->state = s;
        vd->count = 0;

        this->choice_arm (static_cast< choice_arm_tag > (s));
        this->choice_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool LCDCharacterLine_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void LCDCharacterLine_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void LCDCharacterLine_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void LCDCharacterLine_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xsde::cxx::ro_string& ns,
          const ::xsde::cxx::ro_string& n,
          bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (count);
  XSDE_UNUSED (ns);
  XSDE_UNUSED (n);
  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        if (this->DispTitle_parser_)
        {
          this->DispTitle_parser_->pre ();
          ctx.nested_parser (this->DispTitle_parser_);
        }
      }
      else
      {
        if (this->DispTitle_parser_ != 0)
        {
          ::DispTitle* tmp = this->DispTitle_parser_->post_DispTitle ();
          this->DispTitle (tmp);
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        if (this->textObj_parser_)
        {
          this->textObj_parser_->pre ();
          ctx.nested_parser (this->textObj_parser_);
        }
      }
      else
      {
        if (this->textObj_parser_ != 0)
        {
          const ::textObj& tmp = this->textObj_parser_->post_textObj ();
          this->textObj (tmp);
        }

        state = ~0UL;
      }

      break;
    }
    case 2UL:
    {
      if (start)
      {
        if (this->DispFrequency_parser_)
        {
          this->DispFrequency_parser_->pre ();
          ctx.nested_parser (this->DispFrequency_parser_);
        }
      }
      else
      {
        if (this->DispFrequency_parser_ != 0)
        {
          ::DispFrequency* tmp = this->DispFrequency_parser_->post_DispFrequency ();
          this->DispFrequency (tmp);
        }

        state = ~0UL;
      }

      break;
    }
    case 3UL:
    {
      if (start)
      {
        if (this->DispIdentifier_parser_)
        {
          this->DispIdentifier_parser_->pre ();
          ctx.nested_parser (this->DispIdentifier_parser_);
        }
      }
      else
      {
        if (this->DispIdentifier_parser_ != 0)
        {
          const ::DispIdentifier& tmp = this->DispIdentifier_parser_->post_DispIdentifier ();
          this->DispIdentifier (tmp);
        }

        state = ~0UL;
      }

      break;
    }
    case 4UL:
    {
      if (start)
      {
        if (this->DispDuration_parser_)
        {
          this->DispDuration_parser_->pre ();
          ctx.nested_parser (this->DispDuration_parser_);
        }
      }
      else
      {
        if (this->DispDuration_parser_ != 0)
        {
          const ::DispDuration& tmp = this->DispDuration_parser_->post_DispDuration ();
          this->DispDuration (tmp);
        }

        state = ~0UL;
      }

      break;
    }
    case 5UL:
    {
      if (start)
      {
        if (this->DispDutyCycle_parser_)
        {
          this->DispDutyCycle_parser_->pre ();
          ctx.nested_parser (this->DispDutyCycle_parser_);
        }
      }
      else
      {
        if (this->DispDutyCycle_parser_ != 0)
        {
          const ::DispDutyCycle& tmp = this->DispDutyCycle_parser_->post_DispDutyCycle ();
          this->DispDutyCycle (tmp);
        }

        state = ~0UL;
      }

      break;
    }
    case 6UL:
    {
      if (start)
      {
        if (this->DispVoltage_parser_)
        {
          this->DispVoltage_parser_->pre ();
          ctx.nested_parser (this->DispVoltage_parser_);
        }
      }
      else
      {
        if (this->DispVoltage_parser_ != 0)
        {
          const ::DispVoltage& tmp = this->DispVoltage_parser_->post_DispVoltage ();
          this->DispVoltage (tmp);
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for DispTitle_pskel.
//
bool DispTitle_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "textObj" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &DispTitle_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool DispTitle_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void DispTitle_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void DispTitle_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void DispTitle_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "textObj" && ns.empty ())
      {
        if (start)
        {
          if (this->textObj_parser_)
          {
            this->textObj_parser_->pre ();
            ctx.nested_parser (this->textObj_parser_);
          }
        }
        else
        {
          if (this->textObj_parser_ != 0)
          {
            const ::textObj1& tmp = this->textObj_parser_->post_textObj1 ();
            this->textObj (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for DispFrequency_pskel.
//
bool DispFrequency_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "freqValue" && ns.empty ())
        s = 0UL;
      else if (n == "unitPrefix" && ns.empty ())
        s = 1UL;
      else if (n == "dispUnit" && ns.empty ())
        s = 2UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &DispFrequency_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool DispFrequency_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void DispFrequency_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void DispFrequency_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void DispFrequency_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "freqValue" && ns.empty ())
      {
        if (start)
        {
          if (this->freqValue_parser_)
          {
            this->freqValue_parser_->pre ();
            ctx.nested_parser (this->freqValue_parser_);
          }
        }
        else
        {
          if (this->freqValue_parser_ != 0)
          {
            const ::freqValue& tmp = this->freqValue_parser_->post_freqValue ();
            this->freqValue (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "unitPrefix" && ns.empty ())
      {
        if (start)
        {
          if (this->unitPrefix_parser_)
          {
            this->unitPrefix_parser_->pre ();
            ctx.nested_parser (this->unitPrefix_parser_);
          }
        }
        else
        {
          if (this->unitPrefix_parser_ != 0)
          {
            ::unitPrefix* tmp = this->unitPrefix_parser_->post_unitPrefix ();
            this->unitPrefix (tmp);
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "dispUnit" && ns.empty ())
      {
        if (start)
        {
          if (this->dispUnit_parser_)
          {
            this->dispUnit_parser_->pre ();
            ctx.nested_parser (this->dispUnit_parser_);
          }
        }
        else
        {
          if (this->dispUnit_parser_ != 0)
          {
            const ::dispUnit& tmp = this->dispUnit_parser_->post_dispUnit ();
            this->dispUnit (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for unitPrefix_pskel.
//
bool unitPrefix_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "prefix" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &unitPrefix_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool unitPrefix_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void unitPrefix_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void unitPrefix_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void unitPrefix_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "prefix" && ns.empty ())
      {
        if (start)
        {
          if (this->prefix_parser_)
          {
            this->prefix_parser_->pre ();
            ctx.nested_parser (this->prefix_parser_);
          }
        }
        else
        {
          if (this->prefix_parser_ != 0)
          {
            const ::prefix& tmp = this->prefix_parser_->post_prefix ();
            this->prefix (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Attribute validation and dispatch functions for UIXConfig_pskel.
//
bool UIXConfig_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "locale" && ns.empty ())
  {
    if (this->locale_parser_)
    {
      this->locale_parser_->pre ();

      this->locale_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->locale_parser_->_characters (s);

      if (!ctx.error_type ())
        this->locale_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->locale_parser_->post_string ();

        this->locale (tmp);
      }
    }

    return true;
  }

  return false;
}

// Attribute validation and dispatch functions for AppState_pskel.
//
bool AppState_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();

      this->name_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->name_parser_->_characters (s);

      if (!ctx.error_type ())
        this->name_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->name_parser_->post_string ();

        this->name (tmp);
      }
    }

    return true;
  }

  if (n == "desc" && ns.empty ())
  {
    if (this->desc_parser_)
    {
      this->desc_parser_->pre ();

      this->desc_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->desc_parser_->_characters (s);

      if (!ctx.error_type ())
        this->desc_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->desc_parser_->post_string ();

        this->desc (tmp);
      }
    }

    return true;
  }

  return false;
}

// Attribute validation and dispatch functions for mode_pskel.
//
bool mode_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  if (n == "desc" && ns.empty ())
  {
    if (this->desc_parser_)
    {
      this->desc_parser_->pre ();

      this->desc_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->desc_parser_->_characters (s);

      if (!ctx.error_type ())
        this->desc_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->desc_parser_->post_string ();

        this->desc (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::byte_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for textObj_pskel.
//
bool textObj_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  if (n == "desc" && ns.empty ())
  {
    if (this->desc_parser_)
    {
      this->desc_parser_->pre ();

      this->desc_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->desc_parser_->_characters (s);

      if (!ctx.error_type ())
        this->desc_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->desc_parser_->post_string ();

        this->desc (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_min" && ns.empty ())
  {
    if (this->xpos_min_parser_)
    {
      this->xpos_min_parser_->pre ();

      this->xpos_min_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_min_parser_->post_byte ();

        this->xpos_min (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_max" && ns.empty ())
  {
    if (this->xpos_max_parser_)
    {
      this->xpos_max_parser_->pre ();

      this->xpos_max_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_max_parser_->post_byte ();

        this->xpos_max (tmp);
      }
    }

    return true;
  }

  if (n == "xcount" && ns.empty ())
  {
    if (this->xcount_parser_)
    {
      this->xcount_parser_->pre ();

      this->xcount_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xcount_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xcount_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xcount_parser_->post_byte ();

        this->xcount (tmp);
      }
    }

    return true;
  }

  if (n == "align" && ns.empty ())
  {
    if (this->align_parser_)
    {
      this->align_parser_->pre ();

      this->align_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->align_parser_->_characters (s);

      if (!ctx.error_type ())
        this->align_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->align_parser_->post_string ();

        this->align (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for durationValue_pskel.
//
bool durationValue_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  if (n == "desc" && ns.empty ())
  {
    if (this->desc_parser_)
    {
      this->desc_parser_->pre ();

      this->desc_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->desc_parser_->_characters (s);

      if (!ctx.error_type ())
        this->desc_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->desc_parser_->post_string ();

        this->desc (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_min" && ns.empty ())
  {
    if (this->xpos_min_parser_)
    {
      this->xpos_min_parser_->pre ();

      this->xpos_min_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_min_parser_->post_byte ();

        this->xpos_min (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_max" && ns.empty ())
  {
    if (this->xpos_max_parser_)
    {
      this->xpos_max_parser_->pre ();

      this->xpos_max_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_max_parser_->post_byte ();

        this->xpos_max (tmp);
      }
    }

    return true;
  }

  if (n == "xcount" && ns.empty ())
  {
    if (this->xcount_parser_)
    {
      this->xcount_parser_->pre ();

      this->xcount_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xcount_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xcount_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xcount_parser_->post_byte ();

        this->xcount (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::byte_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for dispUnit1_pskel.
//
bool dispUnit1_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  if (n == "desc" && ns.empty ())
  {
    if (this->desc_parser_)
    {
      this->desc_parser_->pre ();

      this->desc_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->desc_parser_->_characters (s);

      if (!ctx.error_type ())
        this->desc_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->desc_parser_->post_string ();

        this->desc (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_min" && ns.empty ())
  {
    if (this->xpos_min_parser_)
    {
      this->xpos_min_parser_->pre ();

      this->xpos_min_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_min_parser_->post_byte ();

        this->xpos_min (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_max" && ns.empty ())
  {
    if (this->xpos_max_parser_)
    {
      this->xpos_max_parser_->pre ();

      this->xpos_max_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_max_parser_->post_byte ();

        this->xpos_max (tmp);
      }
    }

    return true;
  }

  if (n == "xcount" && ns.empty ())
  {
    if (this->xcount_parser_)
    {
      this->xcount_parser_->pre ();

      this->xcount_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xcount_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xcount_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xcount_parser_->post_byte ();

        this->xcount (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for DispDuration_pskel.
//
bool DispDuration_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  return false;
}

// Attribute validation and dispatch functions for DispIdentifier_pskel.
//
bool DispIdentifier_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  if (n == "desc" && ns.empty ())
  {
    if (this->desc_parser_)
    {
      this->desc_parser_->pre ();

      this->desc_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->desc_parser_->_characters (s);

      if (!ctx.error_type ())
        this->desc_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->desc_parser_->post_string ();

        this->desc (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_min" && ns.empty ())
  {
    if (this->xpos_min_parser_)
    {
      this->xpos_min_parser_->pre ();

      this->xpos_min_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_min_parser_->post_byte ();

        this->xpos_min (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_max" && ns.empty ())
  {
    if (this->xpos_max_parser_)
    {
      this->xpos_max_parser_->pre ();

      this->xpos_max_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_max_parser_->post_byte ();

        this->xpos_max (tmp);
      }
    }

    return true;
  }

  if (n == "xcount" && ns.empty ())
  {
    if (this->xcount_parser_)
    {
      this->xcount_parser_->pre ();

      this->xcount_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xcount_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xcount_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xcount_parser_->post_byte ();

        this->xcount (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for dispUnit2_pskel.
//
bool dispUnit2_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  if (n == "desc" && ns.empty ())
  {
    if (this->desc_parser_)
    {
      this->desc_parser_->pre ();

      this->desc_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->desc_parser_->_characters (s);

      if (!ctx.error_type ())
        this->desc_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->desc_parser_->post_string ();

        this->desc (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_min" && ns.empty ())
  {
    if (this->xpos_min_parser_)
    {
      this->xpos_min_parser_->pre ();

      this->xpos_min_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_min_parser_->post_byte ();

        this->xpos_min (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_max" && ns.empty ())
  {
    if (this->xpos_max_parser_)
    {
      this->xpos_max_parser_->pre ();

      this->xpos_max_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_max_parser_->post_byte ();

        this->xpos_max (tmp);
      }
    }

    return true;
  }

  if (n == "xcount" && ns.empty ())
  {
    if (this->xcount_parser_)
    {
      this->xcount_parser_->pre ();

      this->xcount_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xcount_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xcount_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xcount_parser_->post_byte ();

        this->xcount (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for dutyCycle_pskel.
//
bool dutyCycle_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  if (n == "desc" && ns.empty ())
  {
    if (this->desc_parser_)
    {
      this->desc_parser_->pre ();

      this->desc_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->desc_parser_->_characters (s);

      if (!ctx.error_type ())
        this->desc_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->desc_parser_->post_string ();

        this->desc (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_min" && ns.empty ())
  {
    if (this->xpos_min_parser_)
    {
      this->xpos_min_parser_->pre ();

      this->xpos_min_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_min_parser_->post_byte ();

        this->xpos_min (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_max" && ns.empty ())
  {
    if (this->xpos_max_parser_)
    {
      this->xpos_max_parser_->pre ();

      this->xpos_max_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_max_parser_->post_byte ();

        this->xpos_max (tmp);
      }
    }

    return true;
  }

  if (n == "xcount" && ns.empty ())
  {
    if (this->xcount_parser_)
    {
      this->xcount_parser_->pre ();

      this->xcount_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xcount_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xcount_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xcount_parser_->post_byte ();

        this->xcount (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::float_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for DispDutyCycle_pskel.
//
bool DispDutyCycle_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  return false;
}

// Attribute validation and dispatch functions for dispUnit3_pskel.
//
bool dispUnit3_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  if (n == "desc" && ns.empty ())
  {
    if (this->desc_parser_)
    {
      this->desc_parser_->pre ();

      this->desc_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->desc_parser_->_characters (s);

      if (!ctx.error_type ())
        this->desc_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->desc_parser_->post_string ();

        this->desc (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_min" && ns.empty ())
  {
    if (this->xpos_min_parser_)
    {
      this->xpos_min_parser_->pre ();

      this->xpos_min_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_min_parser_->post_byte ();

        this->xpos_min (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_max" && ns.empty ())
  {
    if (this->xpos_max_parser_)
    {
      this->xpos_max_parser_->pre ();

      this->xpos_max_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_max_parser_->post_byte ();

        this->xpos_max (tmp);
      }
    }

    return true;
  }

  if (n == "xcount" && ns.empty ())
  {
    if (this->xcount_parser_)
    {
      this->xcount_parser_->pre ();

      this->xcount_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xcount_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xcount_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xcount_parser_->post_byte ();

        this->xcount (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for voltageValue_pskel.
//
bool voltageValue_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  if (n == "desc" && ns.empty ())
  {
    if (this->desc_parser_)
    {
      this->desc_parser_->pre ();

      this->desc_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->desc_parser_->_characters (s);

      if (!ctx.error_type ())
        this->desc_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->desc_parser_->post_string ();

        this->desc (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_min" && ns.empty ())
  {
    if (this->xpos_min_parser_)
    {
      this->xpos_min_parser_->pre ();

      this->xpos_min_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_min_parser_->post_byte ();

        this->xpos_min (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_max" && ns.empty ())
  {
    if (this->xpos_max_parser_)
    {
      this->xpos_max_parser_->pre ();

      this->xpos_max_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_max_parser_->post_byte ();

        this->xpos_max (tmp);
      }
    }

    return true;
  }

  if (n == "xcount" && ns.empty ())
  {
    if (this->xcount_parser_)
    {
      this->xcount_parser_->pre ();

      this->xcount_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xcount_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xcount_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xcount_parser_->post_byte ();

        this->xcount (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::float_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for DispVoltage_pskel.
//
bool DispVoltage_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  return false;
}

// Attribute validation and dispatch functions for LCDCharacterLine_pskel.
//
bool LCDCharacterLine_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "num" && ns.empty ())
  {
    if (this->num_parser_)
    {
      this->num_parser_->pre ();

      this->num_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->num_parser_->_characters (s);

      if (!ctx.error_type ())
        this->num_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->num_parser_->post_byte ();

        this->num (tmp);
      }
    }

    return true;
  }

  if (n == "max_char" && ns.empty ())
  {
    if (this->max_char_parser_)
    {
      this->max_char_parser_->pre ();

      this->max_char_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->max_char_parser_->_characters (s);

      if (!ctx.error_type ())
        this->max_char_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->max_char_parser_->post_byte ();

        this->max_char (tmp);
      }
    }

    return true;
  }

  return false;
}

// Attribute validation and dispatch functions for textObj1_pskel.
//
bool textObj1_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  if (n == "desc" && ns.empty ())
  {
    if (this->desc_parser_)
    {
      this->desc_parser_->pre ();

      this->desc_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->desc_parser_->_characters (s);

      if (!ctx.error_type ())
        this->desc_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->desc_parser_->post_string ();

        this->desc (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_min" && ns.empty ())
  {
    if (this->xpos_min_parser_)
    {
      this->xpos_min_parser_->pre ();

      this->xpos_min_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_min_parser_->post_byte ();

        this->xpos_min (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_max" && ns.empty ())
  {
    if (this->xpos_max_parser_)
    {
      this->xpos_max_parser_->pre ();

      this->xpos_max_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_max_parser_->post_byte ();

        this->xpos_max (tmp);
      }
    }

    return true;
  }

  if (n == "xcount" && ns.empty ())
  {
    if (this->xcount_parser_)
    {
      this->xcount_parser_->pre ();

      this->xcount_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xcount_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xcount_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xcount_parser_->post_byte ();

        this->xcount (tmp);
      }
    }

    return true;
  }

  if (n == "align" && ns.empty ())
  {
    if (this->align_parser_)
    {
      this->align_parser_->pre ();

      this->align_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->align_parser_->_characters (s);

      if (!ctx.error_type ())
        this->align_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->align_parser_->post_string ();

        this->align (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for DispTitle_pskel.
//
bool DispTitle_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  return false;
}

// Attribute validation and dispatch functions for freqValue_pskel.
//
bool freqValue_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  if (n == "desc" && ns.empty ())
  {
    if (this->desc_parser_)
    {
      this->desc_parser_->pre ();

      this->desc_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->desc_parser_->_characters (s);

      if (!ctx.error_type ())
        this->desc_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->desc_parser_->post_string ();

        this->desc (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_min" && ns.empty ())
  {
    if (this->xpos_min_parser_)
    {
      this->xpos_min_parser_->pre ();

      this->xpos_min_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_min_parser_->post_byte ();

        this->xpos_min (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_max" && ns.empty ())
  {
    if (this->xpos_max_parser_)
    {
      this->xpos_max_parser_->pre ();

      this->xpos_max_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_max_parser_->post_byte ();

        this->xpos_max (tmp);
      }
    }

    return true;
  }

  if (n == "xcount" && ns.empty ())
  {
    if (this->xcount_parser_)
    {
      this->xcount_parser_->pre ();

      this->xcount_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xcount_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xcount_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xcount_parser_->post_byte ();

        this->xcount (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::float_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for dispUnit_pskel.
//
bool dispUnit_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  if (n == "desc" && ns.empty ())
  {
    if (this->desc_parser_)
    {
      this->desc_parser_->pre ();

      this->desc_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->desc_parser_->_characters (s);

      if (!ctx.error_type ())
        this->desc_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->desc_parser_->post_string ();

        this->desc (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_min" && ns.empty ())
  {
    if (this->xpos_min_parser_)
    {
      this->xpos_min_parser_->pre ();

      this->xpos_min_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_min_parser_->post_byte ();

        this->xpos_min (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_max" && ns.empty ())
  {
    if (this->xpos_max_parser_)
    {
      this->xpos_max_parser_->pre ();

      this->xpos_max_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_max_parser_->post_byte ();

        this->xpos_max (tmp);
      }
    }

    return true;
  }

  if (n == "xcount" && ns.empty ())
  {
    if (this->xcount_parser_)
    {
      this->xcount_parser_->pre ();

      this->xcount_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xcount_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xcount_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xcount_parser_->post_byte ();

        this->xcount (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for DispFrequency_pskel.
//
bool DispFrequency_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  if (n == "desc" && ns.empty ())
  {
    if (this->desc_parser_)
    {
      this->desc_parser_->pre ();

      this->desc_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->desc_parser_->_characters (s);

      if (!ctx.error_type ())
        this->desc_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->desc_parser_->post_string ();

        this->desc (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_min" && ns.empty ())
  {
    if (this->xpos_min_parser_)
    {
      this->xpos_min_parser_->pre ();

      this->xpos_min_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_min_parser_->post_byte ();

        this->xpos_min (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_max" && ns.empty ())
  {
    if (this->xpos_max_parser_)
    {
      this->xpos_max_parser_->pre ();

      this->xpos_max_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_max_parser_->post_byte ();

        this->xpos_max (tmp);
      }
    }

    return true;
  }

  if (n == "xcount" && ns.empty ())
  {
    if (this->xcount_parser_)
    {
      this->xcount_parser_->pre ();

      this->xcount_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xcount_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xcount_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xcount_parser_->post_byte ();

        this->xcount (tmp);
      }
    }

    return true;
  }

  return false;
}

// Attribute validation and dispatch functions for prefix_pskel.
//
bool prefix_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  if (n == "desc" && ns.empty ())
  {
    if (this->desc_parser_)
    {
      this->desc_parser_->pre ();

      this->desc_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->desc_parser_->_characters (s);

      if (!ctx.error_type ())
        this->desc_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->desc_parser_->post_string ();

        this->desc (tmp);
      }
    }

    return true;
  }

  if (n == "default_value" && ns.empty ())
  {
    if (this->default_value_parser_)
    {
      this->default_value_parser_->pre ();

      this->default_value_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->default_value_parser_->_characters (s);

      if (!ctx.error_type ())
        this->default_value_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->default_value_parser_->post_string ();

        this->default_value (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for unitPrefix_pskel.
//
bool unitPrefix_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->id_parser_->post_byte ();

        this->id (tmp);
      }
    }

    return true;
  }

  if (n == "desc" && ns.empty ())
  {
    if (this->desc_parser_)
    {
      this->desc_parser_->pre ();

      this->desc_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->desc_parser_->_characters (s);

      if (!ctx.error_type ())
        this->desc_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->desc_parser_->post_string ();

        this->desc (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_min" && ns.empty ())
  {
    if (this->xpos_min_parser_)
    {
      this->xpos_min_parser_->pre ();

      this->xpos_min_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_min_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_min_parser_->post_byte ();

        this->xpos_min (tmp);
      }
    }

    return true;
  }

  if (n == "xpos_max" && ns.empty ())
  {
    if (this->xpos_max_parser_)
    {
      this->xpos_max_parser_->pre ();

      this->xpos_max_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xpos_max_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xpos_max_parser_->post_byte ();

        this->xpos_max (tmp);
      }
    }

    return true;
  }

  if (n == "xcount" && ns.empty ())
  {
    if (this->xcount_parser_)
    {
      this->xcount_parser_->pre ();

      this->xcount_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->xcount_parser_->_characters (s);

      if (!ctx.error_type ())
        this->xcount_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->xcount_parser_->post_byte ();

        this->xcount (tmp);
      }
    }

    return true;
  }

  if (n == "mode" && ns.empty ())
  {
    if (this->mode_parser_)
    {
      this->mode_parser_->pre ();

      this->mode_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->mode_parser_->_characters (s);

      if (!ctx.error_type ())
        this->mode_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->mode_parser_->post_string ();

        this->mode (tmp);
      }
    }

    return true;
  }

  if (n == "selected" && ns.empty ())
  {
    if (this->selected_parser_)
    {
      this->selected_parser_->pre ();

      this->selected_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->selected_parser_->_characters (s);

      if (!ctx.error_type ())
        this->selected_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->selected_parser_->post_byte ();

        this->selected (tmp);
      }
    }

    return true;
  }

  return false;
}

// Character validation functions for DispFrequency_pskel.
//
bool DispFrequency_pskel::
_characters_impl (const ::xsde::cxx::ro_string& s)
{
  this->_any_characters (s);
  return true;
}

// Begin epilogue.
//
//
// End epilogue.

